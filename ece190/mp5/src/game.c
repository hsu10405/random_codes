/*! Game module

    Implements the snake game, which consists of snake head and tail movement and
    random addition of food to the board by providing a function (next_frame) that
    performs one snake game iteration.
    Also provides functions for creating, destroying, and accessing game elements.
*/

#include "game.h"

#include <stdlib.h>

cell * board_cell(board * cur_board, int row, int col)
/*! Given a board, a row, and a column, return a pointer to the corresponding
    cell on the board. (See game.h for board data structure specification)
    This function should be handy for accessing board cells.
*/
{
    //guess we are using pointer arithmetic
	cell * pCell = cur_board->cells; //copy the cell pointer
	
	pCell += ((cur_board->cols) * row) + (col);
	
    return pCell;
}

void randomly_add_food(board * cur_board, float probability)
/*! Given a board and a probability, perform a random binary test
    that passes with the given probability (the random function will
    be useful for this, see "random" man page).  If the test passes, select
    a random cell on the board (each cell should have an equal chance
    of being selected) and change that cell to food if it is currently
    an open cell.  If the selected cell is not open, do nothing.

    We recommend that the default seed be used with the random number
    library, in order to produce deterministic results that make bugs
    easier to track down.  (i.e. just use random without calling srandom)
*/
{
    //pinpoints where the thing will be generated by specifing which cell to place in
	//first figure out where to generate fooda
	
    float num = ((float)rand() / ((float)RAND_MAX));
    if (num < probability){
    	cell * pCell = board_cell(cur_board, rand() % (cur_board->rows), rand() % (cur_board->cols));
        
    	if(*pCell == CELL_OPEN){
    		
    		*pCell = CELL_FOOD; //either food or no food
            
    	}
    }
}

board * create_board(int rows, int cols)
/*! Create an instance of a board structure with the given number of rows
    and columns, initializing elements to open cells and return a pointer
    to it. (See game.h for the specification for the board data structure) 
    The needed memory should be dynamically allocated with the malloc family
    of functions.

    Note that the calloc function is useful for allocating and zeroing
    memory in one call (see "calloc" man page)
*/
{
    board *pBoard = malloc(sizeof(board));
    pBoard->rows = rows;
    pBoard->cols = cols;
    pBoard->cells = calloc(rows * cols, sizeof(cell));
    
    return pBoard;
}

void destroy_board(board * cur_board)
/*! Free memory allocated by create_board to create the given board instance. */
{
    //assuming the snake has been destroyed
	//first destroy cells
	free(cur_board->cells);
	//then the whole board
	free(cur_board);
}

snake * create_snake(board * cur_board, int row, int col, direction heading, int initial_growth)
/*! Create a single-segment snake (See game.h for data structure specification)
    at the given row and column, with the given heading and given growth.
    Needed memory should be dynamically allocated with the malloc family of
    functions.  Mark the corresponding cell on the given board as occupied by
    a snake, and return a pointer to the newly created snake instance */
{
    /* This code is complete; you should not need to modify it */
    snake_segment * segment = malloc(sizeof(snake_segment));
    segment->row = row;
    segment->col = col;
    segment->next = NULL;

    snake * new_snake = malloc(sizeof(snake));
    new_snake->head = segment;
    new_snake->tail = segment;
    new_snake->heading = heading;
    new_snake->growth = initial_growth;

    *board_cell(cur_board, row, col) = CELL_SNAKE;
    return new_snake;
}

void destroy_snake(snake * cur_snake)
/*! Free memory associated with the given snake instance. */
{
	snake_segment * Spointer1;
	snake_segment * Spointer2;
	
	Spointer1 = cur_snake->tail; //setup pointer for first node
	Spointer2 = cur_snake->tail->next; //setup next node
	while(Spointer1 != cur_snake->tail){
		free(Spointer1); //take off the first node
		Spointer1 = Spointer2; //shifting the pointers
		Spointer2 = Spointer1->next;
	}
        free(cur_snake->head);
}

void append_snake_head(snake * cur_snake, board * cur_board, int row, int col)
/*! Add a new snake segment to the given snake with the given row and column.
    This segment is the new snake head; update the snake data structure to integrate
    the new segment.  Needed memory should be allocated with the malloc family of
    functions.  Also mark the corresponding cell on the given board as being occupied
    by a snake.
*/
{
    snake_segment * SegPointer1 = cur_snake->head;
    snake_segment * SegPointer2 = malloc(sizeof(snake_segment)); //create a new snake head

    //filling out the information for both the snake and board

    SegPointer2->row = row; //fill segment location
    SegPointer2->col = col; 
    *board_cell(cur_board, row, col) = CELL_SNAKE; //change cell status
    SegPointer2->next = NULL;
    SegPointer1->next = SegPointer2; //link the head

    cur_snake->head = SegPointer2; //update head
    cur_snake->length += 1; //update snake data

}

void remove_snake_tail(snake * cur_snake, board * cur_board)
/*! Mark the cell on the board corresponding to the snake's last segment
    as open and remove the last segment from the snake.  Update the snake
    data structure to reflect this removal.
    
    If this removal results in the snake having no segments, then set the
    snake's tail and head to NULL to indicate a nonexistent snake.
*/
{
    if(cur_snake->length == 1){
        return;
    }
    snake_segment * SegPointer1 = cur_snake->tail;
    snake_segment * SegPointer2 = cur_snake->tail->next;

    //free the tail
    *board_cell(cur_board, SegPointer1->row, SegPointer1->col) = CELL_OPEN; //change cell status
    free(SegPointer1);//free the last node
    cur_snake->tail = SegPointer2; //update tail
    if(cur_snake->tail == cur_snake->head || cur_snake->length == 0){
        cur_snake->tail = NULL;
        cur_snake->head = NULL;
        
    }
    cur_snake->length -= 1;
}

void update_snake_head(snake * cur_snake, board * cur_board, int growth_per_food)
/*! Attempt to move the head of the given snake one cell (by appending to the snake)
    according to the snake's heading (north is up).  The head can move in the given
    direction if the destination cell is either open or food.  If the cell is food,
    add the given growth per food to the snake's growth counter.  If the destination
    cell is a snake or wall, do nothing.
*/

{
    int temp_row = cur_snake->head->row;
    int temp_col = cur_snake->head->col;
    cell * pCell;
    switch (cur_snake->heading){
        
        case NORTH:
            temp_row--;
        break;
        case SOUTH:
            temp_row++;
        break;
        case EAST:
            temp_col++;
        break;
        case WEST:
            temp_col--;
        break;
    }
//append the new head
    pCell = board_cell(cur_board, temp_row, temp_col);
        if(*pCell == CELL_OPEN || *pCell == CELL_FOOD){
            if(*pCell == CELL_FOOD){
                cur_snake->growth += growth_per_food;

                cur_snake->food += 1;
            }
        append_snake_head(cur_snake, cur_board, temp_row, temp_col);
        }
 
}

void update_snake_tail(snake * cur_snake, board * cur_board)
/*! If the given snake's growth counter is 0, advance the tail of the
    given snake one cell (by removing the current snake tail).
    If the snake's growth counter is positive, decrement the growth
    counter and do not move the snake's tail.
*/
{ 
    /* Implement me! */
    if(cur_snake->growth != 0){
        cur_snake->growth -= 1; //decrement growth counter if there is food
    }
    else{
        remove_snake_tail(cur_snake, cur_board); //delete the last node
    }
    
    
            
}

int next_frame(game * cur_game)
/*! Modify the state of the given snake game to reflect one game iteration.
    This consists of moving human and computer snakes and randomly adding food to the board.
*/
{
    /* This code is complete; you should not need to modify it */
    /* The computer snake gets priority (House always wins ties) */
    update_snake_head(cur_game->computer_snake, cur_game->board, cur_game->growth_per_food);
    update_snake_head(cur_game->human_snake, cur_game->board, cur_game->growth_per_food);
    update_snake_tail(cur_game->computer_snake, cur_game->board);
    update_snake_tail(cur_game->human_snake, cur_game->board);
    randomly_add_food(cur_game->board, cur_game->food_probability);
    return 0;
}
